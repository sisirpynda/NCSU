Binary file .squash.cc.swp matches
dispatch.cc:    if (REN->stall_dispatch(i))
dispatch.cc:      //PAY.buf[index].AL_index = REN->dispatch_inst(PAY.buf[index].C_valid, PAY.buf[index].C_log_reg, PAY.buf[index].C_phys_reg, IS_LOAD(PAY.buf[index].flags),store_flag, IS_BRANCH(PAY.buf[index].flags), IS_AMO(PAY.buf[index].flags), IS_CSR(PAY.buf[index].flags), PAY.buf[index].pc );
dispatch.cc:      PAY.buf[index].AL_index = REN->dispatch_inst(dest_valid, PAY.buf[index].C_log_reg, PAY.buf[index].C_phys_reg, load_flag, store_flag, branch_flag, amo_flag, csr_flag, PAY.buf[index].pc
dispatch.cc://		A_ready = REN->is_ready(PAY.buf[index].A_phys_reg);
dispatch.cc://		B_ready = REN->is_ready(PAY.buf[index].B_phys_reg);
dispatch.cc://		D_ready = REN->is_ready(PAY.buf[index].D_phys_reg);
dispatch.cc:       if (PAY.buf[index].A_valid == true){A_ready = REN->is_ready(PAY.buf[index].A_phys_reg);}
dispatch.cc:      if (PAY.buf[index].B_valid == true){B_ready = REN->is_ready(PAY.buf[index].B_phys_reg);}
dispatch.cc:      if (PAY.buf[index].D_valid == true){D_ready = REN->is_ready(PAY.buf[index].D_phys_reg);}
dispatch.cc:	//	REN->clear_ready(PAY.buf[index].A_phys_reg);
dispatch.cc:	//	REN->clear_ready(PAY.buf[index].B_phys_reg);
dispatch.cc:	//	REN->clear_ready(PAY.buf[index].D_phys_reg);
dispatch.cc:	//	REN->clear_ready(PAY.buf[index].C_phys_reg);
dispatch.cc:      if (PAY.buf[index].C_valid == true) REN->clear_ready(PAY.buf[index].C_phys_reg);
dispatch.cc:	//	A_ready = REN->is_ready(PAY.buf[index].A_phys_reg);
dispatch.cc:	//	B_ready = REN->is_ready(PAY.buf[index].B_phys_reg);
dispatch.cc:	//	D_ready = REN->is_ready(PAY.buf[index].D_phys_reg);
dispatch.cc:	 REN->set_complete(PAY.buf[index].AL_index);
dispatch.cc:	    REN->set_exception(PAY.buf[index].AL_index);
dispatch.cc:         REN->set_exception(PAY.buf[index].AL_index);
dispatch.cc:            REN->set_exception(PAY.buf[index].AL_index);
execute.cc:                REN->set_ready(PAY.buf[index].C_phys_reg);
execute.cc:                REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
execute.cc:               REN->set_ready(PAY.buf[index].C_phys_reg);
execute.cc:               REN->write(PAY.buf[index].C_phys_reg, 0);
execute.cc:            REN->set_exception(al_index);
execute.cc:            REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
execute.cc:            REN->set_ready(PAY.buf[index].C_phys_reg);
execute.cc:        REN->set_ready(PAY.buf[index].C_phys_reg);
execute.cc:        REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
execute.cc:      REN->set_complete(PAY.buf[index].AL_index);
retire.cc:   head_valid = REN->precommit(completed, exception, load_viol, br_misp, val_misp, load, store, branch, amo, csr, offending_PC);
retire.cc:            REN->set_exception(PAY.buf[PAY.head].AL_index);
retire.cc:	REN->commit();
retire.cc:      REN->set_ready(PAY.buf[index].C_phys_reg);
retire.cc:      REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
retire.cc:         REN->set_ready(PAY.buf[index].C_phys_reg);
retire.cc:         REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
rename.cc:   if (REN->stall_branch(bundle_branch) == true) return; //Condition 1: not enough free checkpoints
rename.cc:   if (REN->stall_reg(bundle_dst) == true) return; //condition 2: not enough free physical registers
rename.cc:        PAY.buf[index].A_phys_reg = REN->rename_rsrc(PAY.buf[index].A_log_reg);
rename.cc:        PAY.buf[index].B_phys_reg = REN->rename_rsrc(PAY.buf[index].B_log_reg);
rename.cc:        PAY.buf[index].D_phys_reg = REN->rename_rsrc(PAY.buf[index].D_log_reg);
rename.cc:        PAY.buf[index].C_phys_reg = REN->rename_rdst(PAY.buf[index].C_log_reg);
rename.cc:      RENAME2[i].branch_mask = REN->get_branch_mask();
rename.cc:        PAY.buf[index].branch_ID = REN->checkpoint();
register_read.cc:	      REN->set_ready(PAY.buf[index].C_phys_reg);
register_read.cc:      	PAY.buf[index].A_value.dw = REN->read(PAY.buf[index].A_phys_reg);
register_read.cc:      	PAY.buf[index].B_value.dw = REN->read(PAY.buf[index].B_phys_reg);  
register_read.cc:      	PAY.buf[index].D_value.dw = REN->read(PAY.buf[index].D_phys_reg); 
pipeline.cc:      REN->write(REN->rename_rsrc(i), get_state()->XPR[i]);
pipeline.cc:      REN->write(REN->rename_rsrc(i + NXPR), get_state()->FPR[i]);
pipeline.cc:   return REN->read(REN->rename_rsrc(reg_id));
pipeline.cc:   REN->set_exception(al_index);
pipeline.cc:   REN->set_load_violation(al_index);
pipeline.cc:   REN->set_branch_misprediction(al_index);
pipeline.cc:   REN->set_value_misprediction(al_index);
Binary file .rename.cc.swo matches
Binary file .register_read.cc.swo matches
Binary file .retire.cc.swm matches
Binary file .pipeline.cc.swp matches
Binary file .dispatch.cc.swm matches
checker.cc:      assert(REN->get_exception(PAY.buf[head].AL_index));
Binary file .rename.cc.swp matches
stall:dispatch.cc:    if (REN->stall_dispatch(i))
stall:dispatch.cc:      PAY.buf[index].AL_index = REN->dispatch_inst(PAY.buf[index].C_valid, PAY.buf[index].C_log_reg, PAY.buf[index].C_phys_reg, IS_LOAD(PAY.buf[index].flags),store_flag, IS_BRANCH(PAY.buf[index].flags), IS_AMO(PAY.buf[index].flags), IS_CSR(PAY.buf[index].flags), PAY.buf[index].pc );
stall:dispatch.cc:		A_ready = REN->is_ready(PAY.buf[index].A_phys_reg);
stall:dispatch.cc:		B_ready = REN->is_ready(PAY.buf[index].B_phys_reg);
stall:dispatch.cc:		D_ready = REN->is_ready(PAY.buf[index].D_phys_reg);
stall:dispatch.cc:	//	REN->clear_ready(PAY.buf[index].A_phys_reg);
stall:dispatch.cc:	//	REN->clear_ready(PAY.buf[index].B_phys_reg);
stall:dispatch.cc:	//	REN->clear_ready(PAY.buf[index].D_phys_reg);
stall:dispatch.cc:		REN->clear_ready(PAY.buf[index].C_phys_reg);
stall:dispatch.cc:	//	A_ready = REN->is_ready(PAY.buf[index].A_phys_reg);
stall:dispatch.cc:	//	B_ready = REN->is_ready(PAY.buf[index].B_phys_reg);
stall:dispatch.cc:	//	D_ready = REN->is_ready(PAY.buf[index].D_phys_reg);
stall:dispatch.cc:	 REN->set_complete(PAY.buf[index].AL_index);
stall:dispatch.cc:	    REN->set_exception(PAY.buf[index].AL_index);
stall:dispatch.cc:         REN->set_exception(PAY.buf[index].AL_index);
stall:dispatch.cc:            REN->set_exception(PAY.buf[index].AL_index);
stall:execute.cc:		    REN->set_ready(PAY.buf[index].C_phys_reg);
stall:execute.cc:		    REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
stall:execute.cc:            REN->set_exception(al_index);
stall:execute.cc:		REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
stall:execute.cc:		REN->set_ready(PAY.buf[index].C_phys_reg);
stall:execute.cc:	  REN->set_ready(PAY.buf[index].C_phys_reg);
stall:execute.cc:          REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
stall:execute.cc:      REN->set_complete(PAY.buf[index].AL_index);
stall:retire.cc:   head_valid = REN->precommit(completed, exception, load_viol, br_misp, val_misp, load, store, branch, amo, csr, offending_PC);
stall:retire.cc:            REN->set_exception(PAY.buf[PAY.head].AL_index);
stall:retire.cc:	REN->commit();
stall:retire.cc:      REN->set_ready(PAY.buf[index].C_phys_reg);
stall:retire.cc:      REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
stall:retire.cc:         REN->set_ready(PAY.buf[index].C_phys_reg);
stall:retire.cc:         REN->write(PAY.buf[index].C_phys_reg, PAY.buf[index].C_value.dw);
stall:rename.cc:   bool stall_rename_br = REN->stall_branch(bundle_branch);
stall:rename.cc:   bool stall_rename_reg = REN->stall_reg(bundle_dst);
stall:rename.cc:	      PAY.buf[index].A_phys_reg = REN->rename_rsrc(PAY.buf[index].A_log_reg);
stall:rename.cc:	      PAY.buf[index].B_phys_reg = REN->rename_rsrc(PAY.buf[index].B_log_reg);
stall:rename.cc:	      PAY.buf[index].D_phys_reg = REN->rename_rsrc(PAY.buf[index].D_log_reg);
stall:rename.cc:	      PAY.buf[index].C_phys_reg = REN->rename_rdst(PAY.buf[index].C_log_reg);
stall:rename.cc:     RENAME2[i].branch_mask = REN->get_branch_mask(); 
stall:rename.cc:	      PAY.buf[index].branch_ID = REN->checkpoint();
stall:register_read.cc:	      REN->set_ready(PAY.buf[index].C_phys_reg);
stall:register_read.cc:      	PAY.buf[index].A_value.dw = REN->read(PAY.buf[index].A_phys_reg);
stall:register_read.cc:      	PAY.buf[index].B_value.dw = REN->read(PAY.buf[index].B_phys_reg);  
stall:register_read.cc:      	PAY.buf[index].D_value.dw = REN->read(PAY.buf[index].D_phys_reg); 
stall:pipeline.cc:      REN->write(REN->rename_rsrc(i), get_state()->XPR[i]);
stall:pipeline.cc:      REN->write(REN->rename_rsrc(i + NXPR), get_state()->FPR[i]);
stall:pipeline.cc:   return REN->read(REN->rename_rsrc(reg_id));
stall:pipeline.cc:   REN->set_exception(al_index);
stall:pipeline.cc:   REN->set_load_violation(al_index);
stall:pipeline.cc:   REN->set_branch_misprediction(al_index);
stall:pipeline.cc:   REN->set_value_misprediction(al_index);
stall:checker.cc:      assert(REN->get_exception(PAY.buf[head].AL_index));
stall:lsu.cc:            proc->REN->set_ready(proc->PAY.buf[SQ[sq_head].pay_index].C_phys_reg);
stall:lsu.cc:            proc->REN->write(proc->PAY.buf[SQ[sq_head].pay_index].C_phys_reg, sc_result);
stall:squash.cc:   REN->squash();
stall:writeback.cc:		 REN->resolve(PAY.buf[index].AL_index, PAY.buf[index].branch_ID, 1);
stall:writeback.cc:		 REN->resolve(PAY.buf[index].AL_index, PAY.buf[index].branch_ID, 1);
stall:writeback.cc:	    REN->resolve(PAY.buf[index].AL_index, PAY.buf[index].branch_ID, 0);
stall:writeback.cc:      REN->set_complete(PAY.buf[index].AL_index);
lsu.cc:            proc->REN->set_ready(proc->PAY.buf[SQ[sq_head].pay_index].C_phys_reg);
lsu.cc:            proc->REN->write(proc->PAY.buf[SQ[sq_head].pay_index].C_phys_reg, sc_result);
squash.cc:   REN->squash();
writeback.cc:		 REN->resolve(PAY.buf[index].AL_index, PAY.buf[index].branch_ID, 1);
writeback.cc:		 REN->resolve(PAY.buf[index].AL_index, PAY.buf[index].branch_ID, 1);
writeback.cc:	    REN->resolve(PAY.buf[index].AL_index, PAY.buf[index].branch_ID, 0);
writeback.cc:      REN->set_complete(PAY.buf[index].AL_index);
